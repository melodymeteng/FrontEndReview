### HTTP

1.http的特点：
（1）基于客户端请求/服务端响应
（2）无状态：HTTP对于客户端没有状态存储。
（3）无连接：1.0时对于每一个http请求都是客户端发起--三次握手--服务端响应建立连接--四次挥手关闭连接。每一次HTTP请求都需要经历三次握手四次挥手。1.1以后可以设置keep-alive，并且可以在Nginx设置keepalive-timeout，**设置connection:keep-alive后，在客户端与服务端建立连接后，会在设定的时间内不断开连接，期间客户端再次发起请求不会再进行TCP的三次握手四次挥手，而是保持了与服务端的链接。**
（4）简单快速、灵活
（5）HTTP都是明文传输，并且服务端客户端无法对对方进行身份确认，安全性差。

2.HTTP请求方法：
（1）GET:请求服务器发送一些资源。
（2）POST:发送数据给服务器
（3）OPTION:预检请求，用来获知服务器支持的请求方式
（4）PUT:向服务器发送更新、新增资源的请求
（5）DELTET:删除资源
（6）PATCH：向服务器发送用来局部更新资源
（7）HEAD：向服务器请求资源的头部信息

    1）GET和POST的区别：GET是直接在URL里传输数据，会有历史记录保存，不安全，POST是在请求体存放数据。GET是对服务端安全的，因为只获取数据不会对服务端造成改变并且幂等的（请求多少次结果都一样），而POST会改变服务端数据，并且也不幂等
    2）PUT是幂等的，因为PUT是会指定指向单一资源

3.HTTP2.0的特性
（1）二进制分帧：HTTP2.0中会把请求头，数据体，响应头等分割为二进制的帧，**主要有HEADERS头部帧存放头数据，DATA帧存放数据。一个消息可以分为一个或多个二进制帧，可以乱序发送，然后根据帧的首部流标识再进行组装**
（2）头部压缩：HTTP2.0中会把**头部的数据进行'HPACK'算法压缩**，**浏览器端和服务端之间会建立一个‘首部表’，这个‘首部表’在连接断开前一直存在，表里面用键值对的方式存储了头部数据，在后续请求中，不用传输不变的数据，只用传输有差异的数据即可，有新的头部数据就放在‘首部表’末尾，有更新的数据就替换‘首部表’中对应的数据**。
（3）多路复用：HTTP1.0，1.1时，如果要并发请求多个资源，那么需要多个TCP连接，重复完成三次握手的动作，而且浏览器对于同域名下会有最多6个TCP的限制。**而HTTP2.0中，并发请求多个资源只会建立一个TCP连接，通过这一个TCP可以传输所有的数据。**
（4）服务端推送：可以在浏览器向服务端请求HTML时，服务端主动推送CSS、JS等文件，而不用等到浏览器拿到HTML后再解析。而服务端推送的资源浏览器端也可以拒绝，如果服务端推送的资源在浏览器端已经缓存过了，那么浏览器端可以返回一个RST_STREAM来拒绝。并且服务端推送也必须遵守浏览器的同源策略。

4.HTTP3.0的特性
**如果使用HTTPS，那么会有TCP+TSL两次建立连接的流程，会耗时，第二个TCP会有丢包的现象，一旦丢包TCP为了保证传输的可靠性会丢包重传，那么TCP就会等待重传，这样会造成阻塞**
3.0将基于TCP协议改成了基于UDP协议的QUIC，并且使用TSL1.3。QUIC有以下特点：
（1）由于QUIC基于UDP并且UDP是无连接的，所以可以快速建立连接
（2）QUIC在UDP基础上提供了丢包快传，拥塞控制等一些类似于TCP的特性
（3）QUIC可以多路复用，有多个独立的传输数据流，在有一个数据流丢包的情况下，并不影响另外的数据流
（4）QUIC使用的是TSL1.3加密

5.HTTP常见的状态码
（1）2XX，200请求成功
（2）301：永久重定向、302：临时重定向，HTTP1.1后，把302拆分成303：应该用get方法请求，把POST请求换成GET请求进行重定向和307：临时重定向、304：命中协商缓存
（3）400：请求存在语法错误、403：服务器拒绝访问、404：请求的资源找不到、405：请求的方法服务器不允许、408：客户端请求超时、413：请求体数据过大、431：请求头数据过大
（4）500：服务端报错了、501：服务器可能不支持客户端请求的功能、502：服务器访问的时候出错了、503：服务器很忙或者停机了

### HTTPS

因为HTTP是明文传输数据的，并且双方无法确认身份，导致传输不安全，从而有了HTTPS来保证数据的安全传输。主要有一下几点：

1.在HTTP与TCP/IP中间加了一层SSL/TSL用来加密保证安全性
2.对称加密：加密解密用同一个密钥，但是密钥容易被截获，也不安全
3.非对称加密RSA：例如浏览器端用服务端公开的密钥进行加密，服务端收到后用自己私有的密钥进行解密
4.对称加密+非对称加密：RSA非常慢，那么就先用对称加密来加密一个密钥，然后通过RSA也就是对方的公钥对这个密钥再加密，对方拿到后用公钥对应的私有密钥解密后得到一开始用对称加密的密钥，然后双方就可以用一开始经过对称加密的密钥进行通信了。
5.但是如果此时有中间人把双方的公钥替换成了自己的公钥对数据加密，这样中间人截获数据，用自己的私钥解密后再用劫持的公钥加密发送给对方，对方接收到后根本不知道传输内容已经被中间人看过了
6.服务端使用（CA颁发的）证书，里面有内容和公钥，然后**对这个证书进行hash得到消息摘要**，然后再**用CA的密钥对消息摘要进行加密得到数字签名**，然后证书+数字签名发送给浏览器，**浏览器接收后，对服务端发送过来的证书进行CA的HASH算法，得到消息摘要，然后用CA的公钥对数字签名进行解密得到服务端发过来的消息摘要，浏览器对比这两个摘要是否一致**。这样就大大提高了安全性