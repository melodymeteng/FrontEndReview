# 浏览器内的事件循环

## 1.为什么js在浏览器中有事件循环的机制？
## js是单线程的，如果是多线程，一个线程删除dom操作，一个线程修改dom操作，这样多线程就冲突了
## event loop 实现异步的操作，防止阻塞。

## 2.宏任务、微任务
## 宏任务： 整体代码块、setTimeout、setInterval、node内的I/O操作
## 微任务:  Promise().then()、MutationObserver(()=>{})的callback //https://segmentfault.com/a/1190000012787829

## 3.浏览器内的事件循环
## 为什么要有微任务。因为如果只有宏任务那么将会按照先进先出的顺序挨个执行宏任务，如果在执行宏任务时有比较高优的任务想优先处理，那么将它放入微任务队列中就可以在一个宏任务执行完后被执行。
## 宏任务挨个放入先进先出的宏任务队列中，在每执行完一次宏任务后会去微任务队列中把所有在队列中的微任务按照先进先出的顺序执行一遍。当微任务队列空后，执行下一个宏任务。

## NODE v10及以前环境的事件循环：
## 1、执行完一个阶段中的所有任务。2、执行nextTick队列中的内容。3、执行完微任务队列中的任务
## 宏任务的执行顺序：（每个阶段的内容，总共六个阶段）
（1）timers定时器：执行已经安排过的setTimeout,setInterval的回调
（2）pending callback 待定回调：执行上一次循环延迟到本次的I/O回调
（3）idle , prepare：仅系统内部使用
（4）poll轮询：检索新的I/O事件，执行与I/O相关的回调
（5）check：执行setImmediate()的回调函数
（6）close callback：socket.on('close',() => {}),执行关闭回调


## NODE v11及之后环境与浏览器一样