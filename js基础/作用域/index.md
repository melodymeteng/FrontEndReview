## js引擎从当前的作用域开始查找变量，如果找不到就开始向上一级查找，如果一直到了顶级的全局作用域时，无论找没找到都会停止。
## ReferenceError是在执行RHS查询时在整个作用域链都没有查找到
## TypeError是作用域链查找到了，但是对该变量进行了非法的调用或者引用了null/undefined的值
## LHS 是为了对变量进行赋值操作 RHS 是为了查找变量的值

## 词法作用域
## 词法作用域意味着作用域其实是在函数创建时声明的位置来决定的。（函数在哪里声明，而不是在哪里调用）
## eval(...)通常执行动态创建的代码并且可以在运行期间修改定义期间的作用域，with也可以欺骗作用域，本质上是因为它两在词法分析的时候编译器不知道它两会接受什么参数

## 函数作用域
## function关键字是声明中的第一个词那就是函数声明，否则就是函数表达式
## IIFE立即执行函数，（）包裹，末尾（）执行，1、可以向末尾的（）传参 2、倒置代码的运行顺序，比如将函数传到末尾的（）中

## 块级作用域
## catch会创建块级作用域，其变量只在该作用域内有效
## let可以将变量放在其声明的{...}中，在块级作用域外无法访问该变量，该变量在声明之前不能运行，因为不会变量提升。
## for循环中let i =0;会在每一次循环i都会被重新赋值。因为let将i绑定到for循环中也将i重新绑定到了循环的每一次迭代里。
## const 定义一个不可以更改的常量，但是如果定义的引用类型，那么const定义的只是引用类型的指针，指针指向无法修改，但是指针指向的堆内存存储的数据是可以修改的。

## 提升
## var a = 2;第一步是声明变量a这是在编译器阶段进行的，第二步是给变量a赋值2这是在运行阶段执行的。
## 先声明再赋值，只有声明会被提升。函数声明会被提升，但是函数表达式不会被提升，函数表达式的变量声明会被提升成undefined。
## 提升过程中，函数优先，然后再是变量。