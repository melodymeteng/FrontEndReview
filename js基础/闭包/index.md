## 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数时是在词法作用域之外执行。
## 内部函数访问到外部变量这是闭包很重要的一部分。

function fn(){
    var a = 2;
    function bb(){
        console.log(a)
    }
    return bb
}
var test = fn()
test() ---> 2

## 因为执行fn()时，会return bb这个函数，bb作为值赋值给了test，当调用test时，可以通过bb函数保持着对fn内部词法作用域的引用，这个引用就是闭包。并且当fn()执行完后正常情况来说是会触发垃圾回收，但是由于bb函数保持着对fn函数的引用，所以不会被垃圾回收。
## 在将函数作为值传递时，都会产生闭包。比如回调函数
## 无论通过值传递还是return出来，本质上都是将内部函数传递到函数定义所在的原始作用域外，在执行被暴露函数时，该函数始终保持着对原始作用域的引用。

for(var i=0; i<5; i++){
    setTimeout(function(){
        console.log(i) --->5 5 5 5 5
    },1000)
}
## 因为var定义的变量是全局作用域的，相当于每次循环赋值改变的都是同一个，因为每次循环改变时都是在全局作用域改变，在定时器执行log时会去全局作用域找i的值也就是5
## 1、利用IIFE立即执行函数解决，IIFE函数运行时会建立自己的作用域，将i通过参数传入IIFE，IIFE保持着对i的引用，每一次的循环都是可以通过闭包来引用到i的作用域。
for(var i=0; i<5; i++){
    (function(j){
        setTimeout(function(){
            console.log(j) --->0 1 2 3 4
        },1000)
    })(i)
}
## 2、利用let解决 let在for中会不断用上一次循环的值来重新赋值

## 利用闭包可以做什么
## 1、模块暴露。本质上当函数从内部暴露出来，在包裹内部函数的函数被使用时，就创建了对内部函数的引用（闭包）
